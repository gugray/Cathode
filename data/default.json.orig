{
<<<<<<< HEAD
  "gist": "// Sine SDF by blackle: https://www.shadertoy.com/view/3lSyDG\n// Though ended up not using it here\n#define PI 3.141592653\n\nvec2 rot(vec2 p, float a) {\n    return vec2(p.x*cos(a)-p.y*sin(a), p.x*sin(a)+p.y*cos(a));\n}\n\n// Intensity of faux sine SDF at coordinate\nfloat ifs(vec2 p, float amp, float freq, float ofs, float h12, float h13) {\n    float s = amp * (\n        sin(p.x * freq + ofs) +\n        h12 * sin(p.x * freq * 2.0 + ofs) +\n        h13 * sin(p.x * freq * 3.0 + ofs)\n    );\n    float d = length(p.y - s);\n    return 1.0 - smoothstep(0.0015, 0.02, d);\n}\n\nvoid main() {\n    vec2 uv = (gl_FragCoord.xy / resolution.xy) * 2.0 - 1.0;\n    vec2 p = uv;\n    p.x *= resolution.x/resolution.y;\n\n    vec3 clr;\n    float in1, in2, in3, in4;\n    \n    {\n        vec2 q = p;\n        q = rot(p, PI * sin(time * 0.0003));\n        float amp1 = sin(time * 0.001) * 0.3 + 0.5;\n        float freq1 = (sin(time * 0.0013) + 2.0) * PI * 0.5;\n        float ofs1 = (sin(time * 0.0007) + 2.0) * PI * 0.5 + time * 0.003;\n        in1 = ifs(q, amp1, freq1, ofs1, 0.3, 0.7);\n        clr += 0.7 * in1 * vec3(1.0, 0.4, 0.0);\n    }\n    \n    float amp2 = sin(time * 0.000757) * 0.7;\n    float freq2 = (sin(time * 0.0009546) + 2.0) * PI * 0.5;\n    float ofs2 = (sin(time * 0.001057) + 2.0) * PI * 0.5;\n    in2 = ifs(p + vec2(0.0, 0.6), amp2, freq2, ofs2, 0.3, 0.3);\n    clr += 0.4 * in2 * vec3(0.3, 0.7, 0.6);\n\n    float amp3 = sin(time * 0.000557 + p.x) * 0.7;\n    float freq3 = (sin(time * 0.0004546) + 5.0) * PI * 0.5;\n    float ofs3 = time * 0.002;\n    in3 = ifs(p, amp3, freq3, ofs3, 0.0, 0.6);\n    clr += 0.4 * in3 * vec3(0.3, 0.3, 0.9);\n    \n    vec3 clrClip0 = txFetchUV(txClip0, p);\n    vec3 clrPrev = txFetchUV(txPrev, p);\n    clrPrev = clrPrev * 0.999 - vec3(0.002);\n    clr = clrPrev + clr * 0.05;\n    clr = mix(clr, clrClip0,length(clr) * 0.005);// + 0.05 * pow(clrClip0, vec3(4.0));\n    clr = pow(clr, vec3(0.999));\n    // clr = vec3(0);\n    \n    outColor = vec4(clr.rgb, 1.0);\n}\n"
=======
  "gist": "// Though ended up not using it here\n#define PI 3.141592653\n\nvec2 rot(vec2 p, float a) {\n    return vec2(p.x*cos(a)-p.y*sin(a), p.x*sin(a)+p.y*cos(a));\n}\n\nfloat sdTri(vec2 p, in float r) {\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - r;\n    p.y = p.y + r/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0*r, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\nvoid main() {\n    vec2 uv = (gl_FragCoord.xy / resolution.xy) * 2.0 - 1.0;\n    vec2 p = uv;\n    p.x *= resolution.x/resolution.y;\n\n    vec3 clr = vec3(0., 0., 0.);\n    \n    {\n        vec2 q = p;\n        float peri = 0.2;\n        float a1 = time * 0.00001 * (knob1 - 64.);\n        float a2 = time * 0.00001 * (knob0 - 64.);\n        \n        q.x *= pow(q.y * 0.5 + 1.5, 1.1);\n\t\tq = rot(q, a1);       \n\n        q.y *= pow(q.x * 0.5 + 1.5, 1.1);\n\t\tq = rot(q, a2);       \n        \n        \n        vec2 qq = q;\n        q = mod(q, peri) - 0.5 * peri;\n        \n        q *= 1. + 0.2 * pow(sin(time * 0.00296 + qq.x * 2.), 3.0);\n        q *= 1. + 0.2 * pow(sin(time * 0.00337 + qq.y * 2.), 3.0);\n        \n        float d = sdTri(q, 0.05);\n        float x = 1.0 - step(0.005, abs(d));\n        clr += x * vec3(0.9, 0.2, 0.0);\n    }\n    \n    vec3 prev = txFetchUV(txPrev, p * 0.998);\n\tclr = prev * 0.99 - vec3(0.001) + clr * 0.03;\n    outColor = vec4(clr.rgb, 1.0);\n}\n"
>>>>>>> 85b1df5 (midi pad knobs mapped)
}